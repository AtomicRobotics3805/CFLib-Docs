---
sidebar-position: 2
---

# CommandScheduler
The `CommandScheduler` class runs commands, updates subsystems, and manages gamepad-related commands. The main functions you will be using are [`scheduleCommand()`](#scheduleCommand), [`registerGamepads()`](#registerGamepads), [`registerSubsystems()`](#registerSubsystems), and [`run`](#run).

## Root
- Extends: **N/A**
- Declaration: `object`

## Variables
### runningCommands
`runningCommands` keeps track of all of the commands that are currently running.
- Default value: `mutableListOf<Command>()`
- Type: `val`
- Declaration: `private val`
### commandsToSchedule
`commandsToSchedule` keeps track of all of the commands that are not yet running, but need to be started.
- Default value: `mutableListOf<Command>()`
- Type: `val`
- Declaration: `private val`
### commandsToCancel
`commandsToCancel` is the list of all of the commands that are currently running but should be cancelled.
- Default value: `mutableMapOf<Command, Boolean>()`
- Type: `val`
- Declaration: `private val`
### gamepads
`gamepads` is the list of the gamepads that are actively being used.
- Default value: `mutableListOf<GamepadEx>()`
- Type: `val`
- Declaration: `private val`
### subsystems
- Default value: `mutableListOf<Subsystem>()`
- Type: `val`
- Declaration: `private val`

## Functions
### run()
This function should be run repeatedly; once every loop. It adds commands if the corresponding gamepad buttons are being pushedm it runs the periodic functions in Subsystems, it schedules & cancels any commands that need to be started and stopped, it executes running commands, and it does all that with a smile on its face. The reason why it uses a seperate function to cancel commands instead of cancelling them itself is because removing items from a list while iterating through that list is a wacky idea.
- Declaration: `fun`
- Parameters: **none**
- Returns: `Unit`
### scheduleCommand(command: Command)
`scheduleCommand` schedules a command. When multiple commands are scheduled, they are all run in parallel. Note that [`CommandGroups`](command-groups/CommandGroup.mdx) extend [`Command`](Command), so they can be scheduled the same way commands are scheduled.
- Declaration: `fun`
- Parameters:
    - `command`:
        - Type: [`Command`](Command)
        - Default value: `null`
- Returns: `Unit`
### registerSubsystems(vararg subsystems: Subsystem)
`registerSubsystems` registers one or more subsystems. This list is used to run the subsystems' periodic functions.
- Declaration: `fun`
- Parameters:
    - `subsystems`:
        - Type: [`Subsystem`](../subsystems/Subsystem)
        - Default value: `null`
- Returns: `Unit`
### registerGamepads(vararg gamepads: GamepadEx)
`registerGamepads` registers one or more CustomGamepads. These gamepads will be scanned every loop to see if any buttons are being pressed, and if so, their corresponding commands will be scheduled.
- Declaration: `fun`
- Parameters: 
    - `gamepads`:
        - Type: `GamepadEx`
        - Default value: `null`
- Returns: `Unit`
### unregisterAll()
`unregisterAll` removes every subsystem and gamepad. This function should generally only be used when an OpMode ends.
- Declaration: `fun`
- Parameters: **none**
- Returns: `Unit`
### cancelAll()
`cancelAll` cancels every command. This function should generally only be used when an OpMode ends.
- Declaration: `fun`
- Parameters: **none**
- Returns: `Unit`
### hasCommands()
`hasCommands` returns whether there are commands that are running.
- Declaration: `fun`
- Parameters: **none**
- Returns: `Boolean`
### cancelCommands()
`cancelCommands` cancels every command in the commandsToCancel list.
- Declaration: `private fun`
- Parameters: **none**
- Returns: `Unit`
